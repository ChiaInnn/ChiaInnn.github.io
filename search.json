[{"title":"Hooks-API summary","url":"/2020/06/23/Hooks-API summary/","content":"之前接触到useContext是在项目里面，项目里面主要用在对组件的封装上面，为了获取组件内部的值并用于其他地方所以使用到了useContext。但是使用的时候也只是学着前辈的一些做法去实现，时间紧急没有过多深入去了解相关的内容。今天就了解下相关内容。\n抛开Hooks不说，先了解下context，其实useContext只是对context的另一种实现。\n### Context ###\ncontext的作用只是为需要对它所包含的组件提供全局的数据共享。\n回想一下我们如果要进行父子组件，或者跨越多层来传值的话，之前的做法不就是一层一层地用props去传值。但是，现在使用context以后，如果我们需要使用context中提供的数据，我们不需要从父组件那里通过props去获取，我们可以直接从context的提供者(Provider)那里去获取数据。\ntalk is cheap,show me code.\n\n    //官方Demo\n\t//light是默认值\n\tconst ThemeContext = React.createContext('light');\n\tclass App extends React.Component {\n\t\trender() {\n    // 使用Provider去传递值，而不需要经过中间的组件，value就是要传的值\n    // Any component can read it, no matter how deep it is.\n    \t\treturn (\n      \t\t<ThemeContext.Provider value=\"dark\">\n        \t\t<Toolbar />\n      \t\t</ThemeContext.Provider>\n    \t\t);\n\t\t}\n\t}\n\t//没有经过Toolbar传值\n\tfunction Toolbar() {\n\t\treturn (\n    \t\t<div>\n    \t  \t\t<ThemedButton />\n    \t\t</div>\n\t\t);\n\t}\n\tclass ThemedButton extends React.Component {\n\t// React will find the closest theme Provider above and use its value.\n\t//从上面的注释可以知道context是支持嵌套的\n\tstatic contextType = ThemeContext;\n\t\trender() {\n    \t\treturn <Button theme={this.context} />;\n\t\t}\n\t}\n\n另外也有Class的其他使用方法\n\n    class GrandSon extends React.Component{\n\t\trender();\n\t\treturn(\n\t\t\t<ThemeContext.Consumer>\n\t\t\t\t{(value) => {\n\t\t\t\t\t//some code of GrandSon Component\n\t\t\t\t\t//...\n\t\t\t\t}}\n\t\t\t</ThemeContext.Consumer>\n\t\t)\n\t}\n关于Context还有一个比较重要的点是：当Context Provider的value发生变化时，他的所有子级消费者都会rerender。\n\n但是官方给出的建议是context固然好用，但是对组件复用很不友好。  \n对于复用性要求高的组件官方推荐了通过props传递组件的方式去实现。\n\n    function SplitPane(props) {\n\t\treturn (\n    \t\t<div className=\"SplitPane\">\n      \t\t\t<div className=\"SplitPane-left\">\n        \t\t\t{props.left}\n      \t\t\t</div>\n      \t\t\t<div className=\"SplitPane-right\">\n        \t\t\t{props.right}\n      \t\t\t</div>\n    \t\t</div>\n\t\t);\n\t}\n\tfunction App() {\n\t\treturn (\n    \t\t<SplitPane\n\t\t\t\t//props传组件\n      \t\t\tleft={\n        \t\t\t<Contacts />\n      \t\t\t}\n      \t\t\tright={\n        \t\t\t<Chat />\n      \t\t\t} />\n\t\t);\n\t}\n### useContext ###\nshow code\n\n    //定义context\n\tconst \tLoginContext = React.createContext();\n\tfunction LoginContextFather(){\n\t\t//some code\n\t\t...\n\t\t...\n\t\treturn(\n\t\t\t<LoginContext.provider value={}>\n\t\t\t\t<LoginContextUser>\n\t\t\t</LoginContext.provider>\n\t\t)\n\t}\n\n\tfunction LoginContextUser(){\n\t\t//以后像使用普通变量一样使用即可\n\t\tconst somethingFromContext = useContext(LoginContext);\n\t\treturn(\n\t\t\t//some code\n\t\t)\n\t}\n简单来说其实context和useContext只是写法上有了差异\n### useReducer ###\nuseReducer是useState的替代方案，也可以看做是useState的内部实现。遵从了redux的思想。\nuseReducer适用的场景：   \n1. state逻辑较为复杂且包含多个子值   \n2. 下一state依赖前一state   \nshow code\n\t//通过接受一个reduer和state的值返回一个匹配的dispatch函数和state\n\t//方式1\n    const [state,dispatch] = useReducer(reducer,initialState)\n\t\n\t//方式2\n\tconst [state,dispatch] = useReducer(reducer,{\n\t\tpropName:initialValue\n\t})\n\t//也可以通过初始化函数去初始化值\n\tfunction init(initialCount) {\n\t\treturn {count: initialCount};\n\t}\n\tconst [state, dispatch] = useReducer(reducer, initialCount, init);\n### useMemo ###\n返回一个**memoized value**.*[这是与useCallback的区别]*    \n用于避免复杂运算，和useEffect有点相像。只有依赖数组中值改变了，它才会重新计算结果。\nuseMemo更像是为了性能优化而存在。\n有关依赖数组：依赖项数组不作为参数传递给函数。但是从概念上讲，函数中引用的每个值也应该出现在依赖项数组中。\n> We recommend using the [exhaustive-deps](https://github.com/facebook/react/issues/14920) rule as part of our [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks#installation) package. It warns when dependencies are specified incorrectly and suggests a fix.\nshow code\n    \n    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n\n### useCallBack ###\n返回一个**memoized callback**.\n> useCallback(fn, deps) is equivalent to useMemo(() => fn, deps).\n\n    const memoizedCallback = useCallback(\n\t\t() => {\n    \t\tdoSomething(a, b);\n\t\t},[a, b]\n\t);\n### Reference ###\n- [React官方文档-context](https://reactjs.org/docs/context.html#reactcreatecontext)  \n- [这一次彻底搞定 useReducer - useContext使用](https://www.jianshu.com/p/eddb25cda5f0)\n- [React官方文档-useReducer部分](https://reactjs.org/docs/hooks-reference.html#usereducer)\n","tags":["Hooks"]},{"title":"小知识点","url":"/2020/06/01/小知识点/","content":"### HTML ###\n1.img标签的src为什么不能为空?\nsrc为空被浏览器认为这是一个缺省值，会被默认为当前网页地址。浏览器会用当前路径进行再一次载入，并将其内容作为二进制内容并试图显示。这样会阻塞其他资源的下载。     \nps：在请求src资源时，会将其指向的资源下载并应用到文档内。href影响较小。\nso如果不知道src属性值是什么，可以忽略这个属性，即<img />\n2.js为什么不能写在头部?\n放在头部会阻塞其他资源的下载和处理。当浏览器解析改元素时，会暂停其他资源的下载和处理，直到将该资源加载执行完毕。\n3.forEach和map有什么区别?   \nforEach允许cb修改原数组的值且不会返回数据，map则是分配新的内存空间存储新数组并将其返回   \n4.隐式转换   \n比如在对象（或者函数）里面定义了valueOf，toString函数，js解析器会自动去调用他们。    \ne.g.  在比较大小的时候会自动调用valueOf，有运算符的情况下valueOf的优先级较高，当调用valueOf()方法无法运算时还是会再调用toString()         \nvalueOf会把值改写成原始类型，toString会把值改写成字符串\n\n\n\n<hr/>\n\n\n\n### CSS ###","tags":["小知识"]},{"title":"react生命周期相关问题","url":"/2020/04/07/react生命周期相关问题/","content":"\n\n## 组件初始化 ##  \n**以下介绍基于类组件，部分不适用于函数组件。**      \n![React version16.3 生命周期图片](react生命周期163.png)    \n![react生命周期](react生命周期.jpg)\n### super ###\n通过**调用构造方法**，将props注入子组件。\n### constructor ###\n基类(React Component)的构造方法。用于定义组件的初始内容，e.g. this.state.它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。    \n## 挂载 ##\ncomponentWillMount和componentDidMount都只会被调用一次\n### componentWillMount ###\n在这个生命周期中调用setState不会有任何重新渲染，因为数据还没挂载上去。\n<p style=\"color:#FF4469\">此时还未渲染DOM。</p>\n### render ###\n- 纯函数。\n- props和state的重传递和重赋值，无论值是否真正的改变都会引起组件的重新render。\n- render返回的是react组件\n- 不能再render中执行this.setState \n  \nrender函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其**diff算法**比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。\n\n### componentDidMount ###\n<p style=\"color:#FF4469\">此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染。</p>\n## 更新 ##\n在上文已经说过：props和state的重传递和重赋值，无论值是否真正的改变都会引起组件的重新。所以只要props和state一改变，组件就会update。有时候可能是不必要的更新，e.g.：我们只需要监听值是否改变从而完成一系列的操作，但是值没有改变我们就不要重复更新。react中涉及更新的方法会涉及以下自带参数：prevState,prevProps，nextState，nextProps.可以按需使用。\n### componentWillUpdate ###\n常见的 componentWillUpdate 的用例是在组件更新前，**读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。**   \n这里可以拿到nextProps和nextState。\n### shouldComponentUpdate ###\n用于优化更新，防止不必要更新。实现思路：\n1. 通过nextProps和this.props的某个值的相等关系来返回true/false来决定更新与否。\n2. 通过之前的props和this.props来手动setState，通过state的更新触发更新。\n\n> 其实这种思路的操作也不一定是需要在shouldComponentUpdate里面去完成，也可以放在componentWillUpdate中完成。另外我认为根据业务的需求，我们或许不需要占用一个state去存props的值，只要在发生改变后**去到componentDidUpdate中**完成相应操作就可以，当然如果这个操作仅通过自动渲染就可以完成，那使用state的方法无疑是比较方便的。\n\n### render ###\n同上，不理解可以看图2\n### componentDidUpdate ###\n这里可以拿到prevProps和prevState，即更新前的props和state。\n### other ###\n#### componentWillReceiveProps (nextProps) ####\n在接受父组件改变后的props需要重新渲染组件时用到的比较多    \n接受一个参数nextProps    \n通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件\n#### getDerivedStateFromProps(nextProps, prevState) ####\n\n代替componentWillReceiveProps()。\n**getDerivedStateFromProps前面要加上static保留字，声明为静态方法，不然会被react忽略掉**   \ngetDerivedStateFromProps里面的this为undefined.     \ngetDerivedStateFromProps 中禁止了组件去访问 this.props，强制让开发者去比较nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。\n返回值：null表不更新，否则就返回一个对象更新状态。   \n对比用法： \n \n    componentWillReceiveProps (nextProps) {\n    \tnextProps.openNotice !== this.props.openNotice&&this.setState({\n        openNotice:nextProps.openNotice\n\n    \t}，() => {  \n      \tconsole.log(this.state.openNotice:nextProps)\n      \t//将state更新为nextProps,在setState的第二个参数（回调）可以打印出新的state\n\t\t})\n\t}\n\n    // before\n\tcomponentWillReceiveProps(nextProps) {\n\t\tif (nextProps.isLogin !== this.props.isLogin) {\n    \t\tthis.setState({ \n      \t\tisLogin: nextProps.isLogin,   \n    \t\t});\n\t\t}\n\t\tif (nextProps.isLogin) {\n    \t\tthis.handleClose();\n\t\t}\n\t}\n\t// after\n\tstatic getDerivedStateFromProps(nextProps, prevState) {\n\t\tif (nextProps.isLogin !== prevState.isLogin) {\n    \t\treturn {\n      \t\t\tisLogin: nextProps.isLogin,\n    \t\t};\n\t\t}\n\t\treturn null;\n\t}\n\tcomponentDidUpdate(prevProps, prevState) {\n\t\tif (!prevState.isLogin && this.props.isLogin) {\n    \t\tthis.handleClose();\n\t\t}\n\t}\n\n#### getSnapshotBeforeUpdate(prevProps, prevState) ####\n代替componentWillUpdate。   \n二者的区别就在于：getSnapshotBeforeUpdate可以保证获取的DOM 元素状态和commit的保持一致。    \n它使组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。    \ngetSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。\n此生命周期返回的任何值都将作为参数传递给componentDidUpdate()。\n\n\tclass ScrollingList extends React.Component {\n\t\tconstructor(props) {\n\t\t\tsuper(props);\n\t\t \tthis.listRef = React.createRef();\n\t\t}           \n\t\tgetSnapshotBeforeUpdate(prevProps, prevState) {\n    \t//我们是否要添加新的 items 到列表?\n    \t// 捕捉滚动位置，以便我们可以稍后调整滚动.\n    \t\tif (prevProps.list.length < this.props.list.length) {\n      \t\t\tconst list = this.listRef.current;\n      \t\t\treturn list.scrollHeight - list.scrollTop;\n    \t\t}\n    \t\treturn null;\n\t\t}   \n\t\tcomponentDidUpdate(prevProps, prevState, snapshot) {\n    \t//如果我们有snapshot值, 我们已经添加了 新的items.\n    \t// 调整滚动以至于这些新的items 不会将旧items推出视图。\n    \t// (这边的snapshot是 getSnapshotBeforeUpdate方法的返回值)\n    \t\tif (snapshot !== null) {\n      \t\t\tconst list = this.listRef.current;\n      \t\t\tlist.scrollTop = list.scrollHeight - snapshot;\n    \t\t}\n\t\t}   \n\t\trender() {\n    \t\treturn (\n    \t  \t\t<div ref={this.listRef}>{/* ...contents... */}</div>\n\t\t\t);\n\t\t}\n\t}\n       \n\n## 卸载 ##\n\n### componentWillUnmount ###\n\n可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。\n## Hooks ##\nuseEffect Hook 可以视作 componentDidMount、componentDidUpdate 和 componentWillUnmount 的组合体。\n\n## Reference ##\n- [详解React生命周期(包括react16最新版)](https://www.jianshu.com/p/514fe21b9914)      \n- [React Hook：使用 useEffect](http://www.ptbird.cn/react-hoot-useEffect.html)","tags":["React"]},{"title":"ES6小知识点锦集","url":"/2020/04/01/ES6小知识点锦集/","content":"\n1. with关键字：重复引用对象属性   \n> \n    var obj = {                         \n\t\twith(obj){\n    \t\ta:1,  =>    obj.a = 2;  =>    a = 3;\n    \t\tb:2 common  obj.b = 3; with   b = 4;\n    \t}                                   \n\t}\n    \n2. set： 类似数组的一种数据结构，但是成员值不可以重复。但是在set中，**两个NaN是相等的**。  \n> set的api：\n> \n> s.add() ---类似--- arr.push() //区别：添加两个相等的值只会被add一次\n> \n> set转换成数组 [...new Set(array)]  &  Array.from(new Set(array)) //这两个语句也可以用于**数组去重**\n> \n> s.has()  //判断是否有某个key    \n\nWeakSet： 成员是对象，成员值唯一。   \n特点：**不可遍历**，原因：ws的成员都是弱引用\n\n    \n    \n\n","tags":["ES6"]},{"title":"你不知道的JavaScript(上卷)读书笔记","url":"/2020/04/01/你不知道的JavaScript-上卷-读书笔记/","content":"\n\n## 作用域 ##\n### 代码编译过程 ###\n涉及三个概念：**引擎，编译器，作用域**\n\n**编译会在代码执行的前几微秒进行。**\n> 引擎： 执行代码  \n> \n> 编译器： 声明值/值的定义   \n> 涉及RHS,LHS => RHS: 寻找赋值操作的源头；LHS：寻找复制操作的目标\n> \n> 作用域：根据名称查找变量的一套规则。包括**词法作用域** & **动态作用域**。    \n> 词法作用域只和代码的位置有关系。\n\n作用域嵌套：在当前作用域中找不到变量，就到它的外层嵌套作用域中寻找，直到最外层。如果最后还是没找到，则报错Reference Error。  **在非严格模式下，如果对最外层作用域都找不到的变量赋值，结局就是在全局作用域上创建一个这个变量并赋值。**这是个很诡异的操作。      \n在寻找的时候可能会产生“遮蔽”效果：内部遮蔽外部。[后面会提到对象的“继承”也有遮蔽效果，但那个远比这个复杂]\n\n欺骗词法作用域：eval()，它的第一个参数是字符串，而这个字符串的内容是js代码，它会执行它。类似的函数还有setTimeout()[第一个参数]，setInterval()[第一个参数].另外new Function()[最后一个参数，前几个参数是生成新函数的形参]也有欺骗词法作用域的效果这些用法都是避免被使用的。因为不安全！\n\n","tags":["ES6"]},{"title":"hexo图片显示的坑","url":"/2020/03/30/hexo图片显示的坑/","content":"\n#### drive me crazy ####\n试了很多方法都没办法把图片正常显示出来，控制台显示404.  \n\n然而，检查图片路径和图片都没问题。  \n\n后来看到Hexo官网上给出的推荐方式是抛弃markdown语法，使用标签来引用资源。  \n\n可是试了后，却报错，说{% raw %}{% %} {% endraw %}不被识别。    \n> Nunjucks Error:  [Line 5, Column 4] unknown block tag: attention3\n\n搜了很多办法，比如 `npm install hexo-asset-image --save`，然后修改整个 `node_modules/hexo-asset-image/index.js`也不行.\n\n最后试了修改`node_modules/hexo-asset-image/index.js` 38行为   \n`var srcArray = decodeURI(src).split('/').filter(function(elem){`成功了。\n\n#### summary ####\n\n1. 将博客根目录下的文件 _config.yml 中的 post_asset_folder: false 改为 post_asset_folder: true；   \n2. cmd 在博客根目录下 npm install hexo-asset-image -–save；\n将博客根目录下的文件 package.json 中的 \"hexo-asset-image\": \"1.0.0\" 修改为 \"hexo-asset-image\": \"0.0.3\"，在博客根目录下 cmd npm install；   \n3. 修改博客根目录`\\node_modules\\hexo-asset-image\\index.js` 文件中的第 38 行为\n    `var srcArray = decodeURI(src).split('/').filter(function(elem){;`\n4. 在博客根目录下 cmd hexo clean && hexo g && hexo s，finish。  \n        \n**\\*图片引用还是使用markdown的语法，但是要在图片名前加上post的名字。**\n   \n \n#### reference ####\n\n[记录-Hexo-图片的坑](https://myfavs.win/2019/08/08/%E8%AE%B0%E5%BD%95-Hexo-%E5%9B%BE%E7%89%87%E7%9A%84%E5%9D%91/)\n","tags":["Hexo"]},{"title":"Attention与Self-Attention学习笔记","url":"/2020/03/30/Attention与Self-Attention学习笔记/","content":"\n### Attention & Self-Attention ###\n\n1. attention: 输入x与输出y的每个序列做相似性对比 \n2. self-attention: 句子内部的某个部分与其余部分做相似性比较    \n##### 相似度计算 #####\nattention的相似度计算运用的就是缩放点积     \n![](attention3.png)   \n\n\n> 优点：解决长距离依赖问题 \n>   \n> 缺点：不适用于输入序列n大于表示维度d的情况  === n>d怎么办:每个词不是和所有剩余的词计算相似度，而是只与限制的r个词计算相似度\n\n#### attention应用范围 ####\n目前attention机制在自然语言处理方向的应用非常广泛，大多应用在文本摘要，文本理解，文本分类，机器翻译，人机对话，该机制在NLP中的应用带来的一个优点就是可以通过**可视化attention矩阵**来告诉大家神经网络在进行任务时关注了哪几个部分。   \n有人将attention机制的核心概括为自动加权。\n\n![](attention1.png)\n\n\n#### googleMT的attention model ####  \n![](attention2.png)\n\n根据*Figure1*我们可以看到每个**Muti-Head Attention layer**后面会有一个Add&Norm layer（残差连接和对层），这个层就是用于**结果归一化**，**为了优化深度网络**。  \n\n![](attention4.png)   \n由Muti-Head Attention的图解可以看出Muti-Head的意义就是经过h次attention相似度计算。这样的好处是可以允许模型在不同的表示子空间中学习到相关的信息，可以通过attention可视化来进一步理解。   \n  \n![](attention5.png)   \n\nattention可视化图中：不同颜色代表不同头的结果，颜色越深attention值越大，Self-Attention在这里可以学习到句子内部长距离依赖*making ... more difficult*这个短语。    \n\n![](attention6.png)  \n一个头和两个头学习到的内容对比：两个头不仅可以学习到law 还可以学习到 application依赖关系 => 是不是可以确定头的数量和学习到内容数量之间的相等关系??  \n\n#### attention与CNN的组合模型 ####\n\n- 在卷积前使用attention，通过attention矩阵计算出相应句对的attention feature map，然后连同原来的feature map一起输入到卷积层 \n> 在我的理解中，原来的feature map应该就是指word embedding vector   \n\n- 在池化时进行attention，经过attention对卷积后的表达重新加权后再池化\n- 在卷积前和池化前都使用attention","tags":["Deep Learning"]},{"title":"umi及dva学习笔记及心得","url":"/2020/03/29/umi及dva学习笔记及心得/","content":"\n### 学习链接 ###\n\n\n\n- [DvaJS官方网站](https://dvajs.com/guide/)     \n- [UmiJs官方网站](https://umijs.org/)\n- [dva的最小知识集](https://github.com/dvajs/dva-knowledgemap)\n\n\n### 对umi的简单认识 ###\nUmi其实在我看来是对dva的再次封装，解决了dva的model每次都要手写载入的问题，节省了很多人力操作。     \n另外，Umi比较支持ts的使用，这在官方文档中给出的example也有体现。\n#### 约定式文件 ####\n\n- 它以路由为基础，支持配置式路由和约定式路由两种路由功能。约定式路由依赖严格的文件名和文件组织结构工作。       \n     \n比如分析src/pages目录拿到路由配置。\n    \n    └─ pages               [\n      ├─ index.jsx   =>      { exact: true, path: '/', component: '@/pages/index' },\n      └─ users.jsx           { exact: true, path: '/users', component: '@/pages/users' },\n                           ]\n        \n                                                           \nUmi 里约定目录下有 _layout.tsx时会生成嵌套路由，以 _layout.tsx 为该目录的 layout。layout 文件需要返回一个 React 组件，并通过 props.children 渲染子组件。\n\n    .                                [\n    └── pages                         { exact: false, path: '/users', component: '@/pages/users/_layout',\n      └── users                        routes: [ \n        ├── _layout.jsx       =>        { exact: true, path: '/', component: '@/pages/index' },\n        ├── index.jsx                   { exact: true, path: '/users', component: '@/pages/users' },\n        └── list.jsx                   ], \n                                      },\n                                     ]\n在官方的文档中都记载的很详细。\n\n\n- 约定式Mock文件\n这部分没有使用过，有待后期探索.\n\n\n除此以外，可以使用 dva 来处理数据流，以响应一些复杂的交互操作。是否启用dva可以在配置文件中设置。             \n\n#### 关于配置文件 ####\n           \n默认配置文件为./umirc.js，如果配置比较复杂需要拆分，可以放到 config/config.js中。**两种配置文件，只能选择一个**，且./umirc.js优先级较高。\n> 这一点我深有感触，之前开发项目的时候因为官方文档还没有给出开发者这么明确的提示，所以我两个都创建了以为umi会在编译的时候合并配置文件，并且在config文件中改了很多配置但是结果都没有奏效，后来把umirc.js删了才实现自己想要的东西。当时非常花费时间，这是个坑...\n\n### 对dva简单的认识 ###\ndva 首先是一个基于 [redux](https://github.com/reduxjs/redux) 和 [redux-saga](https://github.com/redux-saga/redux-saga) 的数据流方案.\n通过项目了解到了官方给出的其中2个特性：\n    \n> elm 概念，通过 reducers, effects 和 subscriptions 组织 model；                                                                           \n> 插件机制，比如 dva-loading 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading\n\n\n- 针对第一个特性，我的感受是它使用起来更像Vuex，saga对redux中dispatch方法的一个封装，通过发action通知store更新state。没有完整地学习过源码，因此只是使用感受，毕竟Vue和React在数据流的处理上是截然不同的。Vue使用的双向数据绑定，而React遵从单向数据流。\n   \n因此大部分都会认为对于大项目来说React开发会比Vue开发更省力，人们不需要添加过多复杂的数据拦截操作，只是交给Redux完成数据监听工作。\n\n\n- 对于第二个特性，这对于前端来说是个比较大的解放。我们不需要再重复去处理不同组件的loading状态。\n\n#### 页面中使用model ####\n\ndva 通过 model 的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions 。    \nmodel文件里面包括：\n> namespace ：在全局 state 上的 key\n> \n> state ：初始值，在这里是空数组\n> \n>reducers ：等同于 redux 里的 reducer，接收 action，同步更新 state\n\n定义完model文件后将它引入到index.js文件中。\n但是说到底model里面只放了数据，我们怎么把它和组件连起来？dva提供了connect方法。dva的connect方法其实和redux的connect是一样的。\n> 回忆到之前做的一个项目中：在container 里面导入对应component然后通过mapDispatchToProps把container里面的一些函数（fetchData）映射到component的prop，然后在component里面可以直接调用这个函数，当然被当作组件的prop来对待。此处的container是一个经过connet包装的高阶组件？\n\n#### dva的优缺点 ####\n优点：\n\n1. 特别适合于umi搭配使用，对antd等ui框架支持性也非常不错\n2. 容易上手\n3. 节省了很多重复的人工操作\n\n\n缺点：\n    \n1. 对于大型项目可能不是非常好的选择（有人指出：不建议具备一定规模的非阿里系团队在生产环境中使用）\n\n\n### Todo ###\n- saga的深入学习，特别是要明白saga的Middleware.    \n- [redux-saga](https://redux-saga-in-chinese.js.org/docs/introduction/index.html)\n\n### 参考 ###\n\n- [dva源码解读](http://niexiaotao.cn/2018/04/11/dva%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#%E4%BC%98%E5%8A%BF%E6%80%BB%E7%BB%93)\n- [初识UmiJS](https://www.jianshu.com/p/dc493809a2fd)\n\n\n\n\n ","tags":["前端框架"]}]